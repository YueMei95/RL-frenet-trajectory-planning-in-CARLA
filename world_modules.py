#!/usr/bin/env python

# Copyright (c) 2019 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

# Allows visualising a 2D map generated by vehicles.

"""
Welcome to CARLA No-Rendering Mode Visualizer

    TAB          : toggle hero mode
    Mouse Wheel  : zoom in / zoom out
    Mouse Drag   : move map (map mode only)

    W            : throttle
    S            : brake
    AD           : steer
    Q            : toggle reverse
    Space        : hand-brake
    P            : toggle autopilot
    M            : toggle manual transmission
    ,/.          : gear up/down

    F1           : toggle HUD
    I            : toggle actor ids
    H/?          : toggle help
    ESC          : quit
"""

# ==============================================================================
# -- find carla module ---------------------------------------------------------
# ==============================================================================

import glob
import os
import sys

try:
    sys.path.append(glob.glob('../carla/dist/carla-*%d.%d-%s.egg' % (
        sys.version_info.major,
        sys.version_info.minor,
        'win-amd64' if os.name == 'nt' else 'linux-x86_64'))[0])
except IndexError:
    pass

# ==============================================================================
# -- imports -------------------------------------------------------------------
# ==============================================================================

import carla
from carla import TrafficLightState as tls

import argparse
import logging
import datetime
import weakref
import math
import random

from operator import itemgetter
from agents.strl.controller import VehiclePIDController

try:
    import pygame
    from pygame.locals import KMOD_CTRL
    from pygame.locals import KMOD_SHIFT
    from pygame.locals import K_COMMA
    from pygame.locals import K_DOWN
    from pygame.locals import K_ESCAPE
    from pygame.locals import K_F1
    from pygame.locals import K_LEFT
    from pygame.locals import K_PERIOD
    from pygame.locals import K_RIGHT
    from pygame.locals import K_SLASH
    from pygame.locals import K_SPACE
    from pygame.locals import K_TAB
    from pygame.locals import K_UP
    from pygame.locals import K_a
    from pygame.locals import K_d
    from pygame.locals import K_h
    from pygame.locals import K_i
    from pygame.locals import K_m
    from pygame.locals import K_p
    from pygame.locals import K_q
    from pygame.locals import K_s
    from pygame.locals import K_w
except ImportError:
    raise RuntimeError('cannot import pygame, make sure pygame package is installed')

# ==============================================================================
# -- Constants -----------------------------------------------------------------
# ==============================================================================

# Colors

# We will use the color palette used in Tango Desktop Project (Each color is indexed depending on brightness level)
# See: https://en.wikipedia.org/wiki/Tango_Desktop_Project

COLOR_BUTTER_0 = pygame.Color(252, 233, 79)
COLOR_BUTTER_1 = pygame.Color(237, 212, 0)
COLOR_BUTTER_2 = pygame.Color(196, 160, 0)

COLOR_ORANGE_0 = pygame.Color(252, 175, 62)
COLOR_ORANGE_1 = pygame.Color(245, 121, 0)
COLOR_ORANGE_2 = pygame.Color(209, 92, 0)

COLOR_CHOCOLATE_0 = pygame.Color(233, 185, 110)
COLOR_CHOCOLATE_1 = pygame.Color(193, 125, 17)
COLOR_CHOCOLATE_2 = pygame.Color(143, 89, 2)

COLOR_CHAMELEON_0 = pygame.Color(138, 226, 52)
COLOR_CHAMELEON_1 = pygame.Color(115, 210, 22)
COLOR_CHAMELEON_2 = pygame.Color(78, 154, 6)

COLOR_SKY_BLUE_0 = pygame.Color(114, 159, 207)
COLOR_SKY_BLUE_1 = pygame.Color(52, 101, 164)
COLOR_SKY_BLUE_2 = pygame.Color(32, 74, 135)

COLOR_PLUM_0 = pygame.Color(173, 127, 168)
COLOR_PLUM_1 = pygame.Color(117, 80, 123)
COLOR_PLUM_2 = pygame.Color(92, 53, 102)

COLOR_SCARLET_RED_0 = pygame.Color(239, 41, 41)
COLOR_SCARLET_RED_1 = pygame.Color(204, 0, 0)
COLOR_SCARLET_RED_2 = pygame.Color(164, 0, 0)

COLOR_ALUMINIUM_0 = pygame.Color(238, 238, 236)
COLOR_ALUMINIUM_1 = pygame.Color(211, 215, 207)
COLOR_ALUMINIUM_2 = pygame.Color(186, 189, 182)
COLOR_ALUMINIUM_3 = pygame.Color(136, 138, 133)
COLOR_ALUMINIUM_4 = pygame.Color(85, 87, 83)
COLOR_ALUMINIUM_4_5 = pygame.Color(66, 62, 64)
COLOR_ALUMINIUM_5 = pygame.Color(46, 52, 54)

COLOR_WHITE = pygame.Color(255, 255, 255)
COLOR_BLACK = pygame.Color(0, 0, 0)

# Module Defines
MODULE_WORLD = 'WORLD'
MODULE_HUD = 'HUD'
MODULE_CONTROL = 'CONTROL'
MODULE_INPUT = 'INPUT'

PIXELS_PER_METER = 12

MAP_DEFAULT_SCALE = 0.1
HERO_DEFAULT_SCALE = 1.0

PIXELS_AHEAD_VEHICLE = 150


class ModuleWorld:
    def __init__(self, name, args, timeout):

        self.client = None
        self.name = name
        self.args = args
        self.timeout = timeout

        # World data
        self.world = None
        self.town_map = None

        # Hero actor
        self.hero_actor = None
        self.spawned_hero = None

        self.initSettings = None
        self.frame = None

    def config(self, synchronous=True, no_rendering=True, time_step=None):
        self.initSettings = self.world.get_settings()  # backup the initial setting
        settings = self.world.get_settings()
        settings.synchronous_mode = synchronous
        settings.no_rendering_mode = no_rendering
        settings.fixed_delta_seconds = time_step  # None: default; variable time-step
        self.world.apply_settings(settings)

    def recover_config(self):
        self.world.apply_settings(self.initSettings)  # recover initial setting

    def _get_data_from_carla(self):
        try:
            self.client = carla.Client(self.args.carla_host, self.args.carla_port)
            self.client.set_timeout(self.timeout)
            world = self.client.get_world()
            town_map = world.get_map()
            return world, town_map

        except RuntimeError as ex:
            logging.error(ex)
            pygame.quit()
            sys.exit()

    def start(self):
        self.world, self.town_map = self._get_data_from_carla()

        if self.town_map.name.lower() != 'town04':
            raise NameError('Expecting Town04 but {} is loaded instead'.format(self.town_map.name.lower()))

        self.config(synchronous=True, no_rendering=True, time_step=0.05)
        settings = self.world.get_settings()
        print(settings)

        # Start hero mode by default
        self.select_hero_actor()

    def select_hero_actor(self):
        hero_vehicles = [actor for actor in self.world.get_actors(
        ) if 'vehicle' in actor.type_id and actor.attributes['role_name'] == 'hero']
        if len(hero_vehicles) > 0:
            raise NameError('Hero actor exists in the environment. Close Carla to destroy actors and reopen it')
            # self.hero_actor = random.choice(hero_vehicles)
            # self.hero_transform = self.hero_actor.get_transform()
        else:
            self._spawn_hero()

    def _spawn_hero(self):
        # Get a random blueprint.
        # blueprint = random.choice(self.world.get_blueprint_library().filter(self.args.filter))
        blueprint = self.world.get_blueprint_library().filter('vehicle.tesla.model3')[0]
        blueprint.set_attribute('role_name', 'hero')
        if blueprint.has_attribute('color'):
            # color = random.choice(blueprint.get_attribute('color').recommended_values)
            color = '140,0,0'  # Red
            blueprint.set_attribute('color', color)
        # Spawn the player.
        # while self.hero_actor is None:
        #    spawn_points = self.world.get_map().get_spawn_points()
        #    spawn_point = random.choice(spawn_points) if spawn_points else carla.Transform()
        #    self.hero_actor = self.world.try_spawn_actor(blueprint, spawn_point)

        transform = carla.Transform(carla.Location(x=402.242, y=-20.558, z=1.20001),
                                    carla.Rotation(pitch=0, yaw=-89.4014, roll=0))

        # if transform is infeasible, i.e. collision with other actors, generates error
        self.hero_actor = self.world.spawn_actor(blueprint, transform)
        # use try_spawn_actor in while to find feasible location

        self.hero_transform = self.hero_actor.get_transform()

        # Save it in order to destroy it when closing program
        self.spawned_hero = self.hero_actor

    def tick(self):
        self.world.tick()
        ts = self.world.wait_for_tick()
        if self.frame is not None:
            if ts.frame_count != self.frame + 1:
                logging.warning('--------------- frame skip! -----------------')
        self.frame = ts.frame_count

    def destroy(self):
        if self.spawned_hero is not None:
            print('destroying actors ...')
            self.spawned_hero.destroy()
        if self.world is not None:
            print('recovering world initial configuration ...')
            self.recover_config()


# ==============================================================================
# -- Control -----------------------------------------------------------
# ==============================================================================

class ModuleControl:
    def __init__(self, name):
        self.name = name
        self.dt = 1.0 / 20.0
        self.args_lateral_dict = {
            'K_P': 1.95,
            'K_D': 0.01,
            'K_I': 1.4,
            'dt': self.dt}
        self.args_longitudinal_dict = {
            'K_P': 1.0,
            'K_D': 0,
            'K_I': 1,
            'dt': self.dt}
        self.world = None
        self.vehicleController = None

    def start(self):
        # hud = self.module_manager.get_module(MODULE_HUD)
        # hud.notification("Press 'H' or '?' for help.", seconds=4.0)
        self.world = self.module_manager.get_module(MODULE_WORLD)
        self.world.hero_actor.set_autopilot(False)
        self.vehicleController = VehiclePIDController(self.world.hero_actor,
                                                      args_lateral=self.args_lateral_dict,
                                                      args_longitudinal=self.args_longitudinal_dict)

    def render(self, display):
        pass

    def tick(self):
        x, y = self.world.hero_actor.get_location().x, self.world.hero_actor.get_location().y
        print('x= {0:0.6f},  y= {1:0.6f}'.format(x, y))
        targetWP = self.world.town_map.get_waypoint(self.world.hero_actor.get_location(),
                                                    project_to_road=True).next(distance=10)[0]

        '''
        We cannot modify targetWP. Find out why?
        targetWP.transform.location.x = 10
        '''
        self.world.waypoints = [targetWP]
        targetSpeed = 100
        control = self.vehicleController.run_step(targetSpeed, targetWP)
        self.world.hero_actor.apply_control(control)
